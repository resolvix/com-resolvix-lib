package com.resolvix.lib.transform;

import java.util.Optional;
import java.util.function.Function;

public interface Transform<I, O> {

    /**
     * Transforms the object, {@code input}, of type {@link I} to an object
     * of type {@link O}.
     *
     * @param input the input object to be transformed
     * @return if transformation is possible, the transformed input object;
     *  otherwise, null
     */
    O transform(I input);

    /**
     * Transforms the object, {@code input}, of type {@link I} to an object
     * of type {@link O} where, if transformation is not possible, the object
     * given by the {@code orElse} parameter of type {@link O} is returned.
     *
     * @param input the input object to be transformed
     * @param orElse the output object if transformation of the input object
     *  is not possible
     * @return if transformation is possible, the transformed input object;
     *  otherwise, the object given by the {@code orElse} parameter
     */
    default O transformOrElse(I input, O orElse) {
        O output = transform(input);
        if (output != null)
            return output;
        return orElse;
    }

    /**
     * Transforms the object, {@code input}, of type {@link I}, to an object
     * of type {@link O} where, if transformation is not possible, an
     * exception generated by the method given by the {@code toThrowable}
     * method is thrown.
     *
     * @param input the input object to be transformed
     * @param toThrowable a function responsible for generating the exception
     *  to be thrown if transformation is not possible
     * @return if transformation is possible, the transformed input object
     * @param <T> an object that extends the type {@link Throwable}
     * @throws T if transformation is not possible
     */
    default <T extends Throwable> O transformOrThrow(I input, Function<I, T> toThrowable) throws T {
        O output = transform(input);
        if (output != null)
            return output;
        throw toThrowable.apply(input);
    }

    /**
     * Transforms the object, {@code input}, of type {@link I}, to an
     * object of type {@link O} returning that object boxed as an
     * value-containing {@link Optional} object where, if transformation
     * is not possible an {@code Optional.EMPTY} object is returned.
     *
     * @param input the input object to be transformed
     * @return if transformation is possible, an object of type
     *  {@link Optional<O>} containing the transformed input object;
     *  if transformation is not possible, {@code Optional.EMPTY}
     */
    default Optional<O> optionalTransform(I input) {
        return Optional.ofNullable(transform(input));
    }
}
